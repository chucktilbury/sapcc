
#include "parser.h"
#include "emitters.h"
#include "paths.h"
#include "logger.h"

#define ELEVEL 10

typedef struct {
    Str* base;
    Parser* pstate;
} Emitters;

static Emitters* emitters;

static void opening(FILE* fp) {

    fprintf(fp, "/* This file is generated by SAPCC. Edits may be lost. */\n");
}

static void header_post(FILE* fp) {

    fprintf(fp, "\n#endif\n\n");
    fclose(fp);
}

static FILE* header_pre(const char* name) {

    char buffer[1024];
    char* p;

    strncpy(buffer, raw_string(emitters->base), 10);
    strncat(buffer, name, 1000);
    if(NULL == (p = strrchr(buffer, '.')))
        strcat(buffer, ".h");

    FILE* fp = fopen(buffer, "w");

    p = strrchr(buffer, '.');
        *p = '_';

    opening(fp);
    for(p = buffer; *p != '\0'; p++)
        *p = toupper(*p);

    fprintf(fp, "#ifndef _%s\n", buffer);
    fprintf(fp, "#define _%s\n\n", buffer);
    return fp;
}

static void source_post(FILE* fp) {

    fclose(fp);
}

static FILE* source_pre(const char* name) {

    char buffer[1024];
    char* p;

    strncpy(buffer, raw_string(emitters->base), 10);
    strncat(buffer, name, 1000);
    if(NULL == (p = strrchr(buffer, '.')))
        strcat(buffer, ".c");

    FILE* fp = fopen(buffer, "w");
    opening(fp);
    fprintf(fp, "#include \"util.h\"\n\n");
    return fp;
}

static void init_emitters(Parser* pstate) {

    emitters = _ALLOC_T(Emitters);
    emitters->pstate = pstate;

    TRY {
        emitters->base = get_cmd_str(cmd, "ofile");
    }
    EXCEPT(LIST_ERROR) {
        emitters->base = get_cmd_str(cmd, "file");
        emitters->base = path_basename(emitters->base);
        emitters->base = path_stripext(emitters->base);
    }
    FINAL

    LOG(ELEVEL, "using the output name: %s\n", raw_string(emitters->base));
}

static void emit_scanner_h() {

    FILE* fp = header_pre("_scanner");

    Terminal* term;
    TermListIter* tli = init_list_iterator(emitters->pstate->terminals);
    fprintf(fp, "typedef enum {\n");
    while(iterate_list(tli, &term))
        fprintf(fp, "    _TOK_%s = %d,\n", raw_string(term->name), term->val);
    fprintf(fp, "} TokenType;\n\n");

    fprintf(fp, "typedef struct {\n");
    fprintf(fp, "    Str* str;\n");
    fprintf(fp, "    TokenType type;\n");
    fprintf(fp, "    int line_no;\n");
    fprintf(fp, "    int col_no;\n");
    fprintf(fp, "    Str* fname;\n");
    fprintf(fp, "} Token;\n\n");

    fprintf(fp, "extern Token token;\n\n");

    fprintf(fp, "/*\n    Public Interface.\n */\n");
    fprintf(fp, "Token* create_token();\n");
    fprintf(fp, "void open_file(const char* fname);\n");
    fprintf(fp, "Token* get_token();\n");
    fprintf(fp, "void consume_token();\n");
    fprintf(fp, "const char* tok_to_str(TokenType type);\n\n");

    header_post(fp);
}

static bool is_a_terminal(Str* str) {

    Terminal* term;
    TermListIter* tli = init_list_iterator(emitters->pstate->terminals);
    while(iterate_list(tli, &term))
        if(!comp_string(term->name, str))
            return true;

    return false;
}

static void emit_name(FILE* fp, Str* str) {

    if(is_a_terminal(str))
        fprintf(fp, "_TOK_%s", raw_string(str));
    else
        fprintf(fp, "_nterm_%s", raw_string(str));
}

static int get_rule_size(NonTerminal* nterm) {

    int value = 4;

    Rule* rule;
    RuleListIter* riter = init_list_iterator(nterm->list);
    while(iterate_list(riter, &rule))
        value += length_list(rule->list)+1;

    return value;
}

static void emit_rule_list(FILE* fp, NonTermList* list) {

    NonTerminal* nterm;
    NonTermListIter* ntiter = init_list_iterator(list);
    while(iterate_list(ntiter, &nterm)) {
        fprintf(fp, ",\n\n    %d,\n", get_rule_size(nterm));
        fprintf(fp, "    _nterm_%s,\n", raw_string(nterm->name));
        fprintf(fp, "    %d,\n", nterm->prec);
        fprintf(fp, "    %d", length_list(nterm->list));

        Rule* rule;
        RuleListIter* riter = init_list_iterator(nterm->list);
        while(iterate_list(riter, &rule)) {
            Str* str;
            StrListIter* siter = init_list_iterator(rule->list);

            iterate_list(siter, &str);
            fprintf(fp, ",\n        %d, ", length_list(rule->list));
            emit_name(fp, str);

            while(iterate_list(siter, &str)) {
                fprintf(fp, ", ");
                emit_name(fp, str);
            }
        }
    }
}

static void emit_rule_table(FILE* fp) {

    fprintf(fp, "// parser table encoding\n");

    fprintf(fp, "static uint16_t parser_table[] = {\n");
    fprintf(fp, "    %d", length_list(emitters->pstate->non_terminals));
    emit_rule_list(fp, emitters->pstate->non_terminals);
    fprintf(fp, "\n};\n\n");
}

#include "emit_parser.h"

static void emit_parser_c() {

    FILE* fp = source_pre("_parser");

    NonTerminal* nterm;
    NonTermListIter* ntli = init_list_iterator(emitters->pstate->non_terminals);
    fprintf(fp, "typedef enum {\n");
    while(iterate_list(ntli, &nterm))
        fprintf(fp, "    _nterm_%s = %d,\n", raw_string(nterm->name), nterm->val);
    fprintf(fp, "} NonTerminalType;\n\n");

    fprintf(fp, "#include \"%s_parser.h\"\n", raw_string(emitters->base));
    fprintf(fp, "#include \"%s_scanner.h\"\n\n", raw_string(emitters->base));
    emit_rule_table(fp);
    fprintf(fp, parser_finder_string);
    fprintf(fp, parser_testing_string);

    source_post(fp);
}

static void emit_parser_h() {

    FILE* fp = header_pre("_parser");

    fprintf(fp, "void* parser();\n\n");

    header_post(fp);
}

// static void emit_ast_c() {

//     FILE* fp = source_pre("_ast");
//     source_post(fp);
// }

static void emit_ast_h() {

    FILE* fp = header_pre("_ast");
    header_post(fp);
}

static void emit_visitor_c() {

    FILE* fp = source_pre("_visitor");
    source_post(fp);
}

static void emit_visitor_h() {

    FILE* fp = header_pre("_visitor");
    header_post(fp);
}

void emit_all(Parser* pstate) {

    init_emitters(pstate);
    emit_scanner_h();
    emit_parser_c();
    emit_parser_h();
    //emit_ast_c();
    emit_ast_h();
    emit_visitor_c();
    emit_visitor_h();
}
