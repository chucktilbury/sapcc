# sapcc
Simple As Possible Compiler Compiler

This is a simplified compiler compiler that has a similar function as Flex/YACC or Antlr, but greately simplified. The goal is to create a scanner generator and a parser generator that has a very simple input syntax and good error handling. The output language is C. 

What is intended by SAPCC is to have an input syntax that has very few features, but is still able to capture all constructs that are needed to create a full featured parser for a language compiler. Also, it creates output code that is readable by someone who is not very experienced with C. No doubt there are people who are reading this and question if C++ or some other object based language would be better, but I like C and it's completely adequate for this purpose. 

The output for a given parser is divided into several files for the actual parser, the scanner, and a syntax tree walker. Also a library of utilities is required to actually build the parser that is generated, as well as the code that actually uses the syntax tree. These are in separate files for ease of use.

The syntax tree that is output is not an "abstract" syntax tree. All of the symbols that are in the source code will be in the syntax tree. It less efficient, but it's more simple to create and understand.

The input file consists of 3 parts. They are directives, parser, and scanner. These parts can be placed in separate files or all in the same file. 

## Directives
A directive is an entry in the file that controls how the input is used and how the output is generated. All aspects of the input file are controled by directives.

- %verbosity number - This controls how much status is output on the terminal as the input is parsed and the output is emitted. Valid values are a counting numbers from zero (0) for no output except for actual errors and fiffty (50) for almost every single action that the generator takes.
- %name string - This is the optional base name of the files. The default file names are parser.c, parser.h, scanner.c, scanner.h, syntax.c, syntax.h, and parser.a. If the name is found in any of the input files, then it is prepended to the default name. For example, if the name is "asdf" then the parser header file will be named "asdf_parser.h".
- %prefix string - This is the optional prefix for global symbols generated by the system. For example, the default name for the parser is "parser". If this directive is present and it's value is "asdf" then the global symbol will become "asdf_parser".
- %syntax { C code } - This is custom code to be used instead of the default syntax error handler. A syntax error happens when the parser cannot parse the input. Errors that are generated by the parser generator and the scanner generator are generated internally.
- %code { C code } - This is custom code that is added to the beginning of the syntax module and is intended to support traversing the syntax tree. This is the interface into the actual parsed tree. It is intended that callbacks will be defined here that will interface to more code that implements the actual parser. Multiple code blocks can be specified and they will simply be concatinated in the order in which they are encountered in the parser specification.
- %include string - This is includes another file into the current file. This file is read exactly as if it is part of the current file.
- %scanner { scanner spec } - This is the scanner specification. All of the terminal symbols that are used by the parser are defined here. The parser only accepts names in its syntax and so even single character symbols must be named and specified. See below for the syntax of the scanner spec. If more than one scanner spec is encountered then they will simply be concatinated in the order they are encountered as if they appeared in a single specification.
- %parser { parser spec } - This is the parser specification. This uses non-terminal and terminal symbols to define the structure of the input grammar. If multiple parser specs are encountered, then they are simply concatinated as if they all appear in the same block of definition. See below for more information about the syntax of the parser specification.

## Scanner Specification
The scanner is specified in one or more scanner blocks. (see above) A scanner block consists of one or more scanner rules. A scanner rule consists of an optional symbol, exactly one pattern, and a required code block. The code block is executed when then the pattern is recognized by the scanner driver. It can be used to do translations on the token that was read. One or more %code directives can be optionally embedded in the scanner section to facilitate this functionality. Rules are taken in the order they are received. Rule recogntion is "greedy" in the the longest match that is possible is the one that is taken. This implies that situations where more than one rule matches, the first one that is defined in the one that is taken to be true. For example, keywords may look like a symbol, but for the placement in the specification. This is due to the simplicity of the recognition algorithm. 

```
# This is an example scanner specification with explanations of the elements.
# Comments can appear anywhere in the input file and start with a '#' and end at the new line.

# The is the general form of a scanner block.
%scanner {
  %code {
    // note that this C code is copied to the beginning of the scanner source file verbatim.
    static struct some_code {
     int blabla;
    };
  }

  # These rules do not have any code defined, but the {} are still required.
  # Patterns for string literals are enclosed in "".
  PLUS: "+" {} # This defines a name of PLUS and is recognized with a "+" is seen.
  ADD_ASSIGN: "+=" {} # This defines a name of ADD_ASSIGN and is recognized with "+=" is seen.
  CLASS : "class" {} # Recognize a random keyword.

  # This rule defines a generic symbol.
  # Patterns for regular expressions are enclosed in ()
  SYMB: ([a-zA-Z_][a-zA-Z_0-9]*) {
    // Look up the name or something, or nothing at all. This code is copied to the inside 
    // of the function that recognizes the pattern and it is executed as the function is
    // returning. 
  }

  # This rule defines a complex number.
  # Note that every element in the expression is enclosed in a range. The range is expanded
  # and matched in order according to the rules.
  NUM: ([0-9]+[[.][0-9]+[[eE][+-]?[0-9]+]?]?) {
    // The token has a void pointer that you can use to return arbitrary information.
    token.data = allocate_obj(sizeof(double));
    *((double*)data) = strtod(token.string, NULL);
    // The symbol NUM is created by this definition and it will be the type assigned to the
    // token when the parser receives it. Notice that there are multiple patterns embedded
    // in the rule.
  }

  # This rule recognizes spaces and runs code when they are found, but does not return it
  # to the parser.
  : ([ \t\n\r]+) {
    // Line and column numbers are already tracked by the scanner.
  }

  # This rule recognizes a quoted string that includes newlines. The '.' recognizes all
  # characters that are printable but not white space. If you leave out the new lines
  # then the rule will cause a scanner error if there is no quote encountered before the
  # new line. All characters are copied to the 
  QSTR: (["][ \n\r\t.]*["]) {}
}
```

## Parser Specification
The parser is specified in one or more parser blocks. (see above) A parser block consists of one or more parser rules. A parser rule consists of a non-terminal symbol definition that is followed by one or more patterns. When there is more than one %parser directive encountered, they are simply concatenated in the order they are seen, as if they appeared in a single specification. One or more optional %code directives can be embedded within a parser specification and the code that they contain is concatenated and added to the beginning of the parser file.

```
# This is an example of a set of parser rules.

# This rule demonstrates a recursive list. The recursive element must be first
# and left recursion is not supported.
module
  : module_element module {}
  : module_element {}

# This rule demonstrates that several different non-terminals can make a
# rule.
module_element
  : namespace_definition {}
  : class_definition {}
  : include_definition {}

# This rule demonstrates an indirectly recursive rule.
namespace_definition
  : NAMESPACE SYMBOL OBRACE module CBRACE {}

# This rule demonstrates that blank rules are not allowed.
class_definition
  : CLASS SYMBOL OPAREN SYMBOL CPAREN class_body {}
  : CLASS SYMBOL OPAREN CPAREN class_body {}
  : CLASS SYMBOL class_body {}

# The scanner supports having multiple files open for inclusion.
include_definition
  : INCLUDE SYMBOL

# This is left empty, but that is not correct syntax. Don't want to write a whole
# grammar in this example.
class_body
  : ...

```

